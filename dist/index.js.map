{"version":3,"sources":["../src/index.ts","../src/provider.ts"],"sourcesContent":["import type { Plugin, IAgentRuntime } from '@elizaos/core';\nimport { logger } from '@elizaos/core';\nimport { ClaudeCodeModelProvider } from './provider';\n\nlet providerInstance: ClaudeCodeModelProvider | null = null;\n\nfunction getProvider(runtime: IAgentRuntime): ClaudeCodeModelProvider {\n  if (!providerInstance) {\n    const settings = runtime.character?.settings as Record<string, unknown>;\n    const ccSettings = settings?.claudeCode as Record<string, unknown>;\n\n    const timeout = (ccSettings?.timeout as number) || 120000;\n\n    providerInstance = new ClaudeCodeModelProvider({\n      timeout,\n    });\n\n    logger.info(`[claude-code] Model provider initialized (timeout=${timeout}ms)`);\n  }\n\n  return providerInstance;\n}\n\nexport const claudeCodePlugin: Plugin = {\n  name: 'plugin-claude-code',\n  description: 'Claude Code CLI integration as a model provider',\n\n  models: {\n    TEXT_LARGE: async (runtime, params) => {\n      const provider = getProvider(runtime);\n      const prompt = typeof params === 'string' ? params : (params as any).prompt || '';\n      const settings = runtime.character?.settings as Record<string, unknown>;\n      const ccSettings = settings?.claudeCode as Record<string, unknown>;\n      const model = (ccSettings?.largeModel as 'sonnet' | 'opus' | 'haiku') || 'sonnet';\n      return provider.generateText(runtime, prompt, model);\n    },\n    TEXT_SMALL: async (runtime, params) => {\n      const provider = getProvider(runtime);\n      const prompt = typeof params === 'string' ? params : (params as any).prompt || '';\n      const settings = runtime.character?.settings as Record<string, unknown>;\n      const ccSettings = settings?.claudeCode as Record<string, unknown>;\n      const model = (ccSettings?.smallModel as 'sonnet' | 'opus' | 'haiku') || 'haiku';\n      return provider.generateText(runtime, prompt, model);\n    },\n  },\n\n  actions: [],\n  providers: [],\n  evaluators: [],\n};\n\nexport default claudeCodePlugin;\n\nexport { ClaudeCodeModelProvider } from './provider';\n","import { logger } from '@elizaos/core';\nimport { mkdtemp, rm } from 'node:fs/promises';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\n\nconst TIMEOUT = 120000; // 2 minutes\nconst MAX_PROMPT_LENGTH = 50000;\n\ninterface ClaudeCodeOptions {\n  timeout?: number;\n}\n\n/**\n * Model provider that uses Claude Code CLI to generate responses.\n * Each request gets an isolated temporary workspace that's automatically cleaned up.\n */\nexport class ClaudeCodeModelProvider {\n  private timeout: number;\n\n  constructor(options: ClaudeCodeOptions = {}) {\n    this.timeout = options.timeout || TIMEOUT;\n  }\n\n  async generateText(\n    _runtime: unknown,\n    prompt: string,\n    model: 'sonnet' | 'opus' | 'haiku' = 'sonnet'\n  ): Promise<string> {\n    let tempDir: string | null = null;\n    let proc: ReturnType<typeof Bun.spawn> | null = null;\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n    try {\n      const truncated = prompt.slice(-MAX_PROMPT_LENGTH);\n\n      // Create isolated temp workspace for this request\n      tempDir = await mkdtemp(join(tmpdir(), 'claude-code-'));\n      logger.debug(`[claude-code] Created temp workspace: ${tempDir}`);\n\n      logger.debug(`[claude-code] Generating with model=${model}`);\n      logger.debug(`[claude-code] Prompt preview: ${truncated.slice(0, 500)}...`);\n\n      proc = Bun.spawn(\n        [\n          'claude',\n          '-p',\n          truncated,\n          '--model',\n          model,\n        ],\n        {\n          cwd: tempDir,\n          stdout: 'pipe',\n          stderr: 'pipe',\n        }\n      );\n\n      timeoutId = setTimeout(() => {\n        if (proc) {\n          proc.kill();\n        }\n      }, this.timeout);\n\n      const [output, errors] = await Promise.all([\n        new Response(proc.stdout as ReadableStream).text(),\n        new Response(proc.stderr as ReadableStream).text(),\n      ]);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n\n      const exitCode = await proc.exited;\n\n      if (exitCode !== 0) {\n        const stderr = errors.trim();\n        const stdout = output.trim();\n        logger.error(`[claude-code] Failed (exit=${exitCode})`);\n        logger.error(`[claude-code] stderr: ${stderr}`);\n        logger.error(`[claude-code] stdout: ${stdout}`);\n        throw new Error(`ClaudeCodeError: ${stderr || stdout || 'Unknown error'}`);\n      }\n\n      if (!output || output.trim().length === 0) {\n        throw new Error('EmptyOutput: Claude Code returned nothing');\n      }\n\n      logger.debug(`[claude-code] Response (length=${output.length})`);\n      logger.debug(`[claude-code] Raw output preview: ${output.slice(0, 300)}...`);\n\n      const trimmed = output.trim();\n\n      // If response doesn't start with <response>, wrap it\n      if (!trimmed.startsWith('<response>')) {\n        logger.debug('[claude-code] Adding <response> wrapper');\n        return `<response>\\n${trimmed}\\n</response>`;\n      }\n\n      return trimmed;\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logger.error(`[claude-code] Generation failed: ${msg}`);\n      throw error;\n    } finally {\n      // Ensure timeout is cleared\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      // Ensure process is killed\n      if (proc) {\n        try {\n          proc.kill();\n        } catch {\n          // Process already exited\n        }\n      }\n\n      // Clean up temp workspace\n      if (tempDir) {\n        try {\n          await rm(tempDir, { recursive: true, force: true });\n          logger.debug(`[claude-code] Cleaned up temp workspace: ${tempDir}`);\n        } catch (cleanupError) {\n          logger.warn(`[claude-code] Failed to cleanup ${tempDir}: ${cleanupError}`);\n        }\n      }\n    }\n  }\n\n  async getEmbeddingResponse(_input: string): Promise<number[]> {\n    throw new Error('ClaudeCodeModelProvider does not support embeddings');\n  }\n}\n"],"mappings":"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","names":["logger","logger"]}